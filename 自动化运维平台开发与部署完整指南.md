<!-- 模块说明：自动化平台完整指南。 -->

# 自动化运维平台开发与部署完整指南

## 一、项目概述

### 1.1 项目背景
本项目是一个基于 FastAPI 的自动化运维管理平台，旨在提供脚本调度、任务执行、健康检查和元数据管理等核心功能，支持容器化部署与分布式任务处理。

### 1.2 系统功能
- **健康检查**: 通过 `/health` 接口暴露服务健康状态
- **元数据管理**: 提供 `/meta` 接口获取系统元信息
- **任务管理**: 支持创建、查询、执行运维任务（`/tasks`）
- **脚本管理**: 管理可执行的运维脚本（`/scripts`）
- **运行记录**: 查询任务执行历史（`/runs`）
- **后台作业**: 基于 `worker` 模块异步执行定时或触发式任务

### 1.3 技术架构
- **后端**: FastAPI v0.109.0
- **服务器网关**: Gunicorn v21.2.0
- **异步服务器**: Uvicorn (via uvicorn.workers.UvicornWorker) v0.27.0
- **数据库**: SQLite
- **语言**: Python 3

## 二、开发环境搭建

### 2.1 必需工具
- Docker（推荐）
- Python 3.8+（若本地运行）
- pip

### 2.2 构建命令
```bash
# 构建镜像
docker build -t automation-hub .

# 使用Docker Compose启动
docker compose -f compose.yaml -p automation-hub up --build
```

## 三、开发过程中的关键问题及解决方案

### 3.1 模块导入问题

#### 问题描述
在开发过程中，遇到 `from __future__ import` 语句位置错误的问题。

#### 解决方案
根据Python模块导入规范：
- `from __future__ import` 语句必须位于Python文件的最开始位置，在任何其他代码、空行或注释之前
- 避免使用超出包层级的相对导入（如`...api.models`）
- 推荐使用绝对导入或同级包的相对导入来组织模块引用

### 3.2 API路由和参数问题

#### 问题描述
API端点路径错误，参数名称不匹配等问题。

#### 解决方案
- 确认API端点路径，例如使用 `/runs/runs` 而不是 `/runs`
- 参数使用 [script_name](file://d:\BaiduSyncdisk\个人\思忆集\思集\运维\automation-hub\api\models.py#L25-L25) 和 [parameters](file://d:\BaiduSyncdisk\个人\思忆集\思集\运维\automation-hub\api\models.py#L26-L26) 而不是 `script_id` 和 `args`
- 确保请求参数名与模型定义一致

### 3.3 数据库初始化问题

#### 问题描述
数据库表未正确创建或字段类型不匹配。

#### 解决方案
- 确保 [schema.sql](file://d:\BaiduSyncdisk\个人\思忆集\思集\运维\automation-hub\db\schema.sql) 文件存在于正确位置
- 验证API响应模型中的字段类型与实际返回的数据类型严格一致
- 使用Pydantic模型作为响应体时，确保所有字段的类型声明与实际返回值兼容

### 3.4 任务队列集成问题

#### 问题描述
任务无法正确添加到队列中执行。

#### 解决方案
- 确保任务生产者与消费者之间数据契约的一致性
- 跨服务的数据结构（如脚本清单）字段名称必须严格匹配
- 更新运行状态等关键操作时，必须使用目标函数实际支持的参数名称

## 四、系统功能实现详解

### 4.1 RSS爬取脚本实现

#### fetch_rss.py 脚本功能
```python
def main():
    p = argparse.ArgumentParser(description="Fetch an RSS feed and save JSON + Markdown summary")
    p.add_argument("--url", default="https://www.people.com.cn/rss/politics.xml", help="RSS URL")
    p.add_argument("--limit", type=int, default=10, help="Max items")
    p.add_argument("--out-dir", default="/data/rss", help="Output dir")
    args = p.parse_args()
```

该脚本从指定的RSS源获取数据，限制条目数量，并将结果保存为JSON和Markdown格式。

### 4.2 任务执行流程

#### 任务创建流程
1. 通过 `/runs/runs` 端点提交任务
2. 任务被添加到队列中，状态设为 "queued"
3. Worker进程从队列中获取任务并执行
4. 任务状态更新为 "running"，然后是 "completed" 或 "failed"

#### 任务状态管理
- queued: 任务已提交，等待执行
- running: 任务正在执行
- completed: 任务成功完成
- failed: 任务执行失败

## 五、Docker部署最佳实践

### 5.1 部署前检查
- 检查所有必要的文件是否存在于预期位置
- 确保环境变量正确设置
- 验证Docker守护进程是否已就绪

### 5.2 构建与运行
```bash
# 清理现有环境
docker compose -f compose.yaml -p automation-hub down

# 重新构建并启动
docker compose -f compose.yaml -p automation-hub up --build
```

### 5.3 故障排除
- 遇到"Internal Server Error"等500类错误时，立即检查服务端日志
- 使用 `docker logs` 获取容器日志
- 关注Pydantic的ValidationError具体信息

## 六、Kubernetes迁移指南

### 6.1 环境准备
```bash
# 安装minikube和kubectl
choco install minikube kubernetes-cli -y

# 启动minikube集群
minikube start --driver=docker

# 验证集群状态
kubectl cluster-info
kubectl get nodes
```

### 6.2 资源定义

#### 命名空间定义
```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: automation-hub
```

#### Redis部署
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  namespace: automation-hub
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        ports:
        - containerPort: 6379
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "500m"

---
apiVersion: v1
kind: Service
metadata:
  name: redis
  namespace: automation-hub
spec:
  selector:
    app: redis
  ports:
    - protocol: TCP
      port: 6379
      targetPort: 6379
  type: ClusterIP
```

#### API部署
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
  namespace: automation-hub
spec:
  replicas: 1
  selector:
    matchLabels:
      app: api
  template:
    metadata:
      labels:
        app: api
    spec:
      containers:
      - name: api
        image: automation-hub-api:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8000
        env:
        - name: REDIS_URL
          value: "redis://redis:6379/0"
        - name: WORKSPACE
          value: "/app"
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "1000m"

---
apiVersion: v1
kind: Service
metadata:
  name: api
  namespace: automation-hub
spec:
  selector:
    app: api
  ports:
    - protocol: TCP
      port: 8000
      targetPort: 8000
  type: NodePort  # 使用NodePort以便外部访问
```

#### Worker部署
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: worker
  namespace: automation-hub
spec:
  replicas: 1
  selector:
    matchLabels:
      app: worker
  template:
    metadata:
      labels:
        app: worker
    spec:
      containers:
      - name: worker
        image: automation-hub-worker:latest
        imagePullPolicy: IfNotPresent
        env:
        - name: REDIS_URL
          value: "redis://redis:6379/0"
        - name: WORKSPACE
          value: "/app"
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "1000m"
```

### 6.3 镜像构建与加载

```bash
# 构建Docker镜像
cd "d:\BaiduSyncdisk\个人\思忆集\思集\运维\automation-hub"
docker compose -f compose.yaml build

# 将本地Docker镜像加载到minikube
minikube image load automation-hub-api:latest
minikube image load automation-hub-worker:latest
minikube image load redis:7-alpine
```

### 6.4 应用配置

```bash
# 创建命名空间
kubectl apply -f k8s/namespace.yaml

# 应用所有配置
kubectl apply -f k8s/ -n automation-hub

# 检查部署状态
kubectl get pods -n automation-hub
kubectl get svc -n automation-hub
```

### 6.5 验证服务

1. **检查所有Pod是否处于Running状态**：
```bash
kubectl get pods -n automation-hub
```

2. **获取API服务的NodePort**：
```bash
kubectl get svc api -n automation-hub
```

3. **访问API服务**：
```bash
# 获取minikube IP
$minikubeIp = minikube ip

# 获取API服务的NodePort
$nodePort = kubectl get svc api -n automation-hub -o jsonpath='{.spec.ports[0].nodePort}'

# 访问健康检查端点
curl "http://$minikubeIp:$nodePort/health"

# 访问文档
Start-Process "http://$minikubeIp:$nodePort/docs"
```

4. **或者使用port-forward**（更简单）：
```bash
# 在新终端中运行
kubectl port-forward svc/api 8000:8000 -n automation-hub

# 然后在另一个终端中
curl http://localhost:8000/health
Start-Process http://localhost:8000/docs
```

### 6.6 测试任务执行

```bash
# 触发一个RSS抓取任务
curl -s -X POST http://localhost:8000/runs/runs -H "Content-Type: application/json" -d "{\"script_name\":\"fetch_rss.py\",\"parameters\":{\"url\":\"https://www.people.com.cn/rss/politics.xml\",\"limit\":5}}"

# 检查任务状态（替换为返回的run_id）
curl -s http://localhost:8000/runs/runs/<run_id>
```

## 七、排错与故障诊断

### 7.1 常用诊断命令
```bash
# 查看Pod日志
kubectl logs <pod-name> -n automation-hub

# 查看详细Pod信息
kubectl describe pod <pod-name> -n automation-hub

# 进入Pod执行命令（调试用）
kubectl exec -it <pod-name> -n automation-hub -- sh

# 检查服务状态
kubectl get svc -n automation-hub

# 检查部署状态
kubectl get deployments -n automation-hub
```

### 7.2 常见问题及解决方案

#### 7.2.1 ImagePullBackOff 错误
- **原因**: Kubernetes无法拉取指定的镜像
- **解决方案**: 
  1. 确保镜像已构建并存在
  2. 使用 `minikube image load <image-name>` 将镜像加载到minikube
  3. 在Deployment中设置 `imagePullPolicy: IfNotPresent`

#### 7.2.2 服务不可访问
- **原因**: 端口未正确暴露或服务未正确配置
- **解决方案**:
  1. 检查Service配置，确保selector与Pod标签匹配
  2. 确认端口配置正确
  3. 使用port-forward进行测试

#### 7.2.3 环境变量未生效
- **原因**: 环境变量配置错误或未正确传递
- **解决方案**:
  1. 检查Deployment中env部分的配置
  2. 确保变量名和值正确
  3. 验证Pod重启后配置生效

## 八、关键概念解释

### 8.1 Pod 与 Deployment 的关系
- **Pod**: 是Kubernetes中最小的部署单元，包含一个或多个紧密相关的容器
- **Deployment**: 是管理Pod的控制器，确保指定数量的Pod副本始终运行，提供滚动更新等功能

### 8.2 Service 的服务发现
- 在K8s中，Service为Pod提供稳定的网络端点
- 你的API通过`redis://redis:6379`连接Redis，这里的`redis`是Service名称
- K8s内置DNS会自动将Service名称解析为ClusterIP

### 8.3 NodePort vs port-forward
- **NodePort**: 将服务暴露在节点的特定端口上（30000-32767），适合生产环境
- **port-forward**: 临时将本地端口转发到集群中的服务，适合开发测试

## 九、验收标准

1. `kubectl get pods -n automation-hub` 所有Pod状态为**Running**
2. 能够通过`curl http://localhost:8000/health`访问健康检查端点
3. 能够通过浏览器访问`http://localhost:8000/docs`查看API文档
4. 能够成功触发`/runs/runs`端点并看到任务执行成功

## 十、进阶拓展

### 10.1 持久化存储
在生产环境中，需要配置PersistentVolume和PersistentVolumeClaim来持久化数据：

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: data-pvc
  namespace: automation-hub
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
```

### 10.2 配置管理
使用ConfigMap和Secret管理配置：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: automation-hub-config
  namespace: automation-hub
data:
  DATABASE_PATH: "/data/database.db"
  SCRIPTS_DIR: "/app/scripts"
```

### 10.3 水平扩展
配置HPA（Horizontal Pod Autoscaler）根据负载自动伸缩：

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: api-hpa
  namespace: automation-hub
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: api
  minReplicas: 1
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

## 十一、总结

通过本指南，我们完成了自动化运维平台从开发、调试到Kubernetes部署的完整流程。关键要点包括：

1. **开发过程**: 注意模块导入规范、API路由配置、数据模型定义等细节
2. **部署流程**: 从Docker Compose到Kubernetes的迁移，包括镜像构建、资源定义、服务暴露等
3. **排错技巧**: 掌握常用kubectl命令，学会通过日志和描述信息快速定位问题
4. **最佳实践**: 遵循Kubernetes设计原则，合理规划资源、网络和服务发现

这个平台可以作为运维自动化的基础框架，后续可以根据实际需求扩展更多功能模块。